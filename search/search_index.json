{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"<p><code>mitmify</code> is an HTTP(S) 1.x proxy server which enables traffic to be intercepted and dynamically transformed.</p>"},{"location":"#usage","title":"Usage","text":"<p>The <code>mitmify</code> library is accessible via Maven Central.</p> <p><code>mitmify</code> requires Java 17+.</p>"},{"location":"#design","title":"Design","text":"<p>The proxy Server proxies requests as displayed in the diagram below.</p> <p></p> <p>The first Interceptor that finds the Request to be interceptable is used to intercept the Request and Response. As such, be mindful of the Interceptor order in Server.create. Interceptor instances with overly generic interceptable implementations should be nearer to the end of the provided array of Interceptor, otherwise they may supersede the correct Interceptor.</p> <p>The Proxier handles the execution of the proxy request. To customize how proxy requests are executed, a Proxier implementation may be specified when creating the Server or within an Interceptor.</p> <p>To proxy HTTPS requests, the Server must be created with a CA certificate and (the corresponding) private key. Additionally, the given CA certificate must be trusted by the (proxy) client(s). This is necessary to be able to establish a TLS connection between the client and proxy Server, so the Server can decrypt and intercept the Request. The TLS related interactions of proxying an HTTPS request is depicted below.</p> <p></p>"},{"location":"#examples","title":"Examples","text":""},{"location":"#intercept-a-proxied-http-response","title":"Intercept a proxied HTTP response","text":"<pre><code>// Initialize a mock web server which is the target for proxy requests\nMockWebServer().use { target -&gt;\n  // Enqueue a mock response for the proxied request\n  target.enqueue(MockResponse().setBody(\"Hello!\"))\n  // Define a response interceptor to modify the proxy response\n  class ResponseInterceptor : Interceptor {\n    // Use this interceptor for \"hello\" requests\n    override fun interceptable(request: Request) = request.uri.path == \"/hello\"\n    override fun intercept(response: Response) {\n      // Print the response from the proxy request\n      response.body?.let(::String)?.also { println(\"Intercepted: $it\") }\n      // Change the proxy response body\n      response.body = \"Goodbye!\".toByteArray()\n    }\n  }\n  // Create and start a proxy server\n  Server.create(ResponseInterceptor()).start(PORT).use { _ -&gt;\n    // Initialize an HTTP client that uses the proxy server\n    val client =\n      OkHttpClient.Builder().proxySelector(ProxySelector.of(InetSocketAddress(PORT))).build()\n    // Execute a request then print the (intercepted) response body\n    client\n      .newCall(okhttp3.Request.Builder().url(target.url(\"/hello\")).build())\n      .execute()\n      .use { response -&gt; response.body?.use(ResponseBody::string) }\n      ?.also { println(\"Received: $it\") }\n  }\n}\n</code></pre> <pre><code>Intercepted: Hello!\nReceived: Goodbye!\n</code></pre>"},{"location":"#proxy-an-https-request","title":"Proxy an HTTPS request","text":"<p>The HTTPS examples use okhttp-tls to simplify the creation of certificates.</p>"},{"location":"#proxy-server-uses-a-trusted-certificate-chain","title":"Proxy server uses a trusted certificate chain","text":"<p>This example code is intended to be representative of a realistic HTTPS deployment.</p> <pre><code>// Create a root certificate authority\nval rootCertificate = HeldCertificate.Builder().certificateAuthority(1).build()\n// Create an intermediate certificate authority (signed by the root certificate)\nval intermediateCertificate =\n  HeldCertificate.Builder().certificateAuthority(0).signedBy(rootCertificate).build()\n// Create a client certificates that trust the root certificate\nval clientCertificates =\n  HandshakeCertificates.Builder().addTrustedCertificate(rootCertificate.certificate).build()\n// Create and start a proxy server which uses the intermediate certificate authority to generate\n// trusted certificates for the (destination of) proxy requests\nServer.create(\n  // To proxy HTTPS requests the proxy server requires a CA certificate and private key.\n  // The proxy client(s) must trust the provided CA certificate so the proxy server can generate a\n  // (trusted) certificate to establish a TLS connection (to access the proxy request)\n  certificatePath = intermediateCertificate.certificatePem().asFile(\"proxy.pem\"),\n  privateKeyPath = intermediateCertificate.privateKeyPkcs8Pem().asFile(\"proxy.key\")\n)\n  .start(PORT)\n  .use { _ -&gt;\n    // Initialize an HTTPS client that uses the proxy server and client certificates\n    val client =\n      OkHttpClient.Builder()\n        .proxySelector(ProxySelector.of(InetSocketAddress(PORT)))\n        .sslSocketFactory(\n          clientCertificates.sslSocketFactory(), clientCertificates.trustManager\n        )\n        .build()\n    // Execute an HTTPS request and expect a successful response code\n    client\n      .newCall(Request.Builder().url(\"https://httpbin.org/get\").build())\n      .execute()\n      .use(Response::isSuccessful)\n      .also(::println)\n  }\n</code></pre>"},{"location":"#proxy-server-executes-a-request-with-mtls","title":"Proxy server executes a request with mTLS","text":"<pre><code>// Create a root certificate for the client and server to trust\nval rootCertificate = HeldCertificate.Builder().certificateAuthority(0).build()\n// Create a server certificate (signed by the root certificate) for the mock web server\nval serverCertificate =\n  HandshakeCertificates.Builder()\n    .addTrustedCertificate(rootCertificate.certificate)\n    .heldCertificate(\n      HeldCertificate.Builder()\n        .addSubjectAlternativeName(localhost)\n        .signedBy(rootCertificate)\n        .build()\n    )\n    .build()\n// Create a client certificate (signed by the root certificate) for the client\nval clientCertificate =\n  HandshakeCertificates.Builder()\n    .addTrustedCertificate(rootCertificate.certificate)\n    .heldCertificate(HeldCertificate.Builder().signedBy(rootCertificate).build())\n    .build()\n// Initialize an HTTPS mock web server which is the target for proxy requests\nMockWebServer()\n  .apply { useHttps(serverCertificate.sslSocketFactory(), false) }\n  .apply { requestClientAuth() }\n  .use { target -&gt;\n    target.enqueue(MockResponse())\n    // Create a proxier that uses the client certificates\n    val proxier =\n      Proxier.create(\n        OkHttpClient.Builder()\n          .sslSocketFactory(\n            clientCertificate.sslSocketFactory(), clientCertificate.trustManager\n          )\n          .build()\n      )\n    // Create and start the proxy server that can connect to the mock web server\n    Server.create(\n      proxier = proxier,\n      // Provide a certificate and private key to proxy HTTPS requests\n      certificatePath = proxyCertPath,\n      privateKeyPath = proxyKeyPath\n    )\n      .start(PORT)\n      .use { _ -&gt;\n        // Initialize an HTTPS client that uses the proxy server and trusts its certificate\n        val client =\n          OkHttpClient.Builder()\n            .proxySelector(ProxySelector.of(InetSocketAddress(PORT)))\n            .sslSocketFactory(\n              clientSocketFactory,\n              clientTrustManager\n            )\n            .build()\n        // Execute an HTTPS the request to the target and expect response to be successful\n        client\n          .newCall(Request.Builder().url(target.url(\"/\")).build())\n          .execute()\n          .use(Response::isSuccessful)\n          .also(::println)\n      }\n  }\n</code></pre>"},{"location":"#license","title":"License","text":"<pre><code>Copyright 2022 c-fraser\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    https://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Kudos to mitmproxy and proxyee which significantly influenced the implementation of <code>mitmify</code>.</p>"}]}